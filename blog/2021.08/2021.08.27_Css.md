!!title CSS
!!summary Statically generating CSS + stylesheets.
!!keywords Rust stylesheet css starting over blog generation html ir generator md
!!series blog_gen

## 0617

Before I continue, I want to make one change. Compilation is taking a long time, and I think it's due to the inclusion of `rayon`. This will be a dependency that is critical to everything, but I don't want to run it right now. 

I'll update the `Cargo.toml` file.

```
// Cargo.toml
[features]
multithread = ["rayon"]

[dependencies]
ansi_term = "0.12"
rayon = {version = "1.5", optional = true}
walkdir = "2.3"
```

I'll then update the areas where Rayon is called.

```
// main.rs

...

// Parse all intermediate representations

let ir_results: Vec<Res<IntermediateRepresentation>> = crawl_files(crawled_files, &context);

let ir = match map_results(ir_results) {
    Ok(ir) => ir,
    Err(_) => return,
};

...

fn crawl_files(
    files: Vec<Item<crawler::File>>,
    context: &Arc<Context>,
) -> Vec<Res<IntermediateRepresentation>> {
    #[cfg(feature = "multithread")]
    {
        use rayon::prelude::*;
        return files
            .par_iter()
            .map(|f| parser::execute(f, context.clone()))
            .collect();
    }

    files
        .iter()
        .map(|f| parser::execute(f, context.clone()))
        .collect()
}
```

Then update the `generator` module with the same thing.

```
// generator/mod.rs

...

// Create all files
generate_all(ir, &context)

...


fn generate_all(ir: Vec<Item<IntermediateRepresentation>>, context: &Arc<Context>) -> Vec<Res<()>> {
    #[cfg(feature = "multithread")]
    {
        use rayon::prelude::*;
        return ir
            .par_iter()
            .map(|item| generate(item, context.clone()))
            .collect();
    }

    ir.iter()
        .map(|item| generate(item, context.clone()))
        .collect()
}

...

```

Compilation is a bit faster now, but not terribly so.

The next thing I'll want to do before continuing is adding CSS Cards. I don't know what it'll look like yet so it's a very simplistic file that is littered with `todo!()`s. 

I'll wire that up to the `generator` so I can generate it.

```
// generator/mod.rs

pub fn execute(ir: Vec<Item<IntermediateRepresentation>>, context: Arc<Context>) -> Vec<Res<()>> {
    // Clear output directory
    match fs::remove_dir_all(&context.output.to_string()) {
        Ok(_) => {}
        Err(e) => match e.kind() {
            std::io::ErrorKind::NotFound => {
                // nothing to do here.
            }
            _ => {
                return vec![Res::Error {
                    location: Some(Location {
                        column: 0,
                        file: String::default(),
                        line: 0,
                        path: context.output.to_string(),
                    }),
                    msg: format!("{:?}", e.kind()),
                }]
            }
        },
    }

    // Create new output directory
    let output_dir = context.output.to_string();
    match make_dir(&output_dir) {
        Ok(_) => {}
        Err(e) => return e,
    }

    // Create assets directory
    match make_dir(&format!("{}{}", output_dir, ASSETS)) {
        Ok(_) => {}
        Err(e) => return e,
    }

    // Create any autogenerated files
    let ir = {
        let mut ir = ir;

        let stylesheet = Stylesheet::new(&context);

        let css = IntermediateRepresentation::Css(Css {
            contents: stylesheet.to_html().into_bytes(),
            file_name: "styles.css".into(),
        });

        ir.push(Item {
            item: css,
            location: None,
        });

        ir
    };

    // Create all files
    generate_all(ir, &context)
}
```

The `Stylesheet` is now implemented. I'll utilize some various types to represent `Selectors` and `CSS`. It is very basic and will evolve as I get a better understanding of the domain.

```
// html/stylesheet.rs
use super::Html;
use crate::{theme::Theme, Context};
use std::sync::Arc;

#[derive(Debug, Clone, PartialEq)]
pub struct Stylesheet {
    classes: Vec<Class>,
    theme: Theme,
}

impl Stylesheet {
    pub fn new(context: &Arc<Context>) -> Self {
        Self {
            classes: Class::all(),
            theme: context.theme.clone(),
        }
    }
}

impl Html for Stylesheet {
    fn to_html(&self) -> String {
        let generated_css = self
            .classes
            .iter()
            .map(|c| c.css(&self.theme))
            .collect::<Vec<Css>>()
            .iter()
            .map(|css| css.to_str().into())
            .collect::<Vec<String>>()
            .join("\n");

        format!("{}", generated_css)
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum Class {
    Card,
}

impl Class {
    pub fn all() -> Vec<Self> {
        vec![Self::Card]
    }

    pub fn css(&self, theme: &Theme) -> Css {
        match self {
            Class::Card => card(self, theme),
        }
    }

    pub fn selector(&self) -> Selector {
        match self {
            Class::Card => "card".into(),
        }
    }
}

fn card(class: &Class, theme: &Theme) -> Css {
    let main_rules = vec![
        "box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2)".into(),
        format!("background: {}", theme.fill_primary_light_mode.to_html()),
        "display: flex".into(),
        "flex-direction: column".into(),
        "margin: 16px".into(),
        "padding: 16px".into(),
        "text-align: justify".into(),
        "width: 100%".into(),
        "max-width: initial".into(),
        "word-wrap: normal".into(),
    ];

    let hover_rules: Vec<String> = vec!["box-shadow: 0 8px 12px 0 rgba(0, 0, 0, 0.2)".into()];

    let combine_rules = |rules: Vec<String>| {
        rules
            .iter()
            .map(|r| format!("{};", r))
            .collect::<Vec<String>>()
            .join("\n")
    };

    let main_class = format!(
        ".{} {{ {} }}",
        class.selector().to_str(),
        combine_rules(main_rules)
    );

    let hover_class = format!(
        ".{}:hover {{ {} }}",
        class.selector().to_str(),
        combine_rules(hover_rules)
    );

    format!("{}\n{}", main_class, hover_class).into()
}

#[derive(Debug, Clone, PartialEq)]
pub struct Css(String);

impl Css {
    pub fn to_str(&self) -> &str {
        &self.0
    }
}

impl From<&'static str> for Css {
    fn from(s: &'static str) -> Self {
        Self(s.into())
    }
}

impl From<String> for Css {
    fn from(s: String) -> Self {
        Self(s)
    }
}

#[derive(Debug, Clone, PartialEq)]
pub struct Selector(String);

impl Selector {
    pub fn to_str(&self) -> &str {
        &self.0
    }
}

impl From<&'static str> for Selector {
    fn from(s: &'static str) -> Self {
        Self(s.into())
    }
}
```

The generated results look like so:

```
// styles.css
.card { box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2);
background: rgba(255,255,255,255);
display: flex;
flex-direction: column;
margin: 16px;
padding: 16px;
text-align: justify;
width: 100%;
max-width: initial;
word-wrap: normal; }
.card:hover { box-shadow: 0 8px 12px 0 rgba(0, 0, 0, 0.2); }
```

I'll work on wiring this up to the intermediate representation after I get the basic `body` and `html` selectors added. I may also add a `spacing_px` to the config to control all margins. One of the benefits of doing generated CSS is that you don't have to manually replace everything when updates are made.