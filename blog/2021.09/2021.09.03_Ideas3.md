!!title Ideas 3
!!summary Brainstorming architecture + online games continued.
!!keywords Rust architecture multiplayer turn based elixir underlords hexagonal architecture
!!series

## 2239

Back to the game ideas. I'm now more interested in utilizing Rust for the core of all clients, utilizing hexagonal architecture.

Like Erlang, utilize message passing between the 'shell', combined with some form of autogenerated native client. 


Tech choices:
* Server layer 
* * Elixir
* * * Elixir/Erlang are perfect for a large scale server. I like the idea of the BEAM and think it would be very useful for concurrent applications. 
* * * It is functional and has seemingly good interop with Rust as a NIF
* Business layer
* * Rust
* * * A low level language I am familiar with
* * * ADTs + static typing seem like excellent canidates
* * * `[no_std]` preferred? Would that help enforce a hexagonal architecture?
* * * A good ecosystem which I can wrap if necessary
* * * Done in a functional way
* * * HEAVY usage of ADTs and functions to make them more concise
* Client layer
* * Android
* * * Kotlin
* * * I do not prefer Java
* * iOs
* * * Swift
* * * No particular reason except to see what the language is like
* Console
* * Unity or Unreal? 
* PC
* * Rust + Godot?
* Web
* * TypeScript + React
* * * While Clojure, PureScript or Elm would be fun, I'll go mainstream
* * * [ADTs](https://www.javiercasas.com/articles/typescript-adts)
* * * [Types](https://blog.logrocket.com/pattern-matching-and-type-safety-in-typescript-1da1231a2e34/)


## Game Idea
Idea:
* Economy based, like Underlords. Win streaks, lose streaks and interest.
* RTS tech tree
* Starting positioning is key. Use a larger starting area that Underlords to see how that evolves gameplay.
* Terrain variety
* Faster + more rounds than Underlords
* Hyperfast. 30s tops per round.

Architecture:
* Erlang-based backend
* * Elixir for the server: 'glue' + db
* * Rust as a NIF. The input is pulled from an ETS/Redis, ran through Rust, then put back. Treated as a functional lib that can be called.
* * [Rustler](https://github.com/rusterlium/rustler) will be used for writing NIFs. I'll likely write a script that automates part of this.
* RabbitMQ for messaging
* Native clients that render some form of DSL to interact with the backend
* * When releasing versions, have a locally seeded db. This then gets updated as time goes on through the server.
* * The locally seeded db is utilized when no internet is available or the player does not want to play online + update. 
* * When they want to go online, it pulls data from the server. 
* Network + Serialization
* * Ratelimiting
* * Elixir Channels for communication protocol
* * REST for non-websockety things (login, logout, etc.)
* * Preprocessor that looks at Rust structs + enum, then outputs DTO's in all client + server languages. Haskell is another option.
* * FlatBuffers for communication. [See article](https://google.github.io/flatbuffers/). The spec is small, it's fast, and it's supported in most languages. 
* * Serialization is done in Rust, passed as a byte array to Elixir's channel, then sent out. Deserialized on the client, stored in the local db, done.