
<!DOCTYPE html>
<html>
    <head>
        <title>Ideas 3</title>
        <!-- metadata -->
        <meta charset="UTF-8">
<meta name="description" content="Brainstorming architecture + online games continued.">
<meta name="keywords" content="Rust, architecture, multiplayer, turn, based, elixir, underlords, hexagonal, architecture">
<meta name="author" content="Eric Olson">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
        <!-- css -->
        <link rel="stylesheet" href="assets/styles.css">
    </head>
    <body>
        <!-- page class -->
        <div class=pageLight>
            <!-- content wrapper -->
            <div class=contentWrapperLight>
                <!-- content -->
                <div   ><div   ><div   class="navbottomLight"><a id="previous_page_link" href="2021.09.03_Fragments.html"  >ðŸ¡„ Previous</a>
<a id="next_page_link" href="2021.09.04_NewLanguage.html"  >Forward ðŸ¡†</a></div>
<div   class="navtopLight"><a id="homeNav" href="index.html"  >Home</a>
<a id="catalogNav" href="catalog.html"  >Catalog</a>
<a id="projectsNav" href="projects.html"  >Projects</a>
<a id="aboutMeNav" href="about_me.html"  >About Me</a></div></div>
<div   ><h2 id="title"  ><a  href="#title"  >#</a>
2021.09.03 - Ideas 3</h2>
<div   >



<div   class="cardLight hoverShadowLight outlinedLight paddedbottomLight paddedtopLight shadowLight alignmentleftLight"><h3 id="2239"  ><a  href="#2239"  >#</a>
 2239</h3>
<div   ><p   >Back to the game ideas. I'm now more interested in utilizing Rust for the core of all clients, utilizing hexagonal architecture.</p>
<p   >Like Erlang, utilize message passing between the 'shell', combined with some form of autogenerated native client. </p>
<p   >Tech choices:</p>
<ul   class="listLight"><li><div   >Server layer </div></li><li><div   ><ul   class="listLight"><li><div   >Elixir</div></li></ul></div></li><li><div   ><ul   class="listLight"><li><div   ><ul   class="listLight"><li><div   >Elixir/Erlang are perfect for a large scale server. I like the idea of the BEAM and think it would be very useful for concurrent applications. </div></li></ul></div></li></ul></div></li><li><div   ><ul   class="listLight"><li><div   ><ul   class="listLight"><li><div   >It is functional and has seemingly good interop with Rust as a NIF</div></li></ul></div></li></ul></div></li><li><div   >Business layer</div></li><li><div   ><ul   class="listLight"><li><div   >Rust</div></li></ul></div></li><li><div   ><ul   class="listLight"><li><div   ><ul   class="listLight"><li><div   >A low level language I am familiar with</div></li></ul></div></li></ul></div></li><li><div   ><ul   class="listLight"><li><div   ><ul   class="listLight"><li><div   >ADTs + static typing seem like excellent canidates</div></li></ul></div></li></ul></div></li><li><div   ><ul   class="listLight"><li><div   ><ul   class="listLight"><li><div   ><span   class="codeblockDark outlinedDark">[no_std]</span>
 preferred? Would that help enforce a hexagonal architecture?</div></li></ul></div></li></ul></div></li><li><div   ><ul   class="listLight"><li><div   ><ul   class="listLight"><li><div   >A good ecosystem which I can wrap if necessary</div></li></ul></div></li></ul></div></li><li><div   ><ul   class="listLight"><li><div   ><ul   class="listLight"><li><div   >Done in a functional way</div></li></ul></div></li></ul></div></li><li><div   ><ul   class="listLight"><li><div   ><ul   class="listLight"><li><div   >HEAVY usage of ADTs and functions to make them more concise</div></li></ul></div></li></ul></div></li><li><div   >Client layer</div></li><li><div   ><ul   class="listLight"><li><div   >Android</div></li></ul></div></li><li><div   ><ul   class="listLight"><li><div   ><ul   class="listLight"><li><div   >Kotlin</div></li></ul></div></li></ul></div></li><li><div   ><ul   class="listLight"><li><div   ><ul   class="listLight"><li><div   >I do not prefer Java</div></li></ul></div></li></ul></div></li><li><div   ><ul   class="listLight"><li><div   >iOs</div></li></ul></div></li><li><div   ><ul   class="listLight"><li><div   ><ul   class="listLight"><li><div   >Swift</div></li></ul></div></li></ul></div></li><li><div   ><ul   class="listLight"><li><div   ><ul   class="listLight"><li><div   >No particular reason except to see what the language is like</div></li></ul></div></li></ul></div></li><li><div   >Console</div></li><li><div   ><ul   class="listLight"><li><div   >Unity or Unreal? </div></li></ul></div></li><li><div   >PC</div></li><li><div   ><ul   class="listLight"><li><div   >Rust + Godot?</div></li></ul></div></li><li><div   >Web</div></li><li><div   ><ul   class="listLight"><li><div   >TypeScript + React</div></li></ul></div></li><li><div   ><ul   class="listLight"><li><div   ><ul   class="listLight"><li><div   >While Clojure, PureScript or Elm would be fun, I'll go mainstream</div></li></ul></div></li></ul></div></li><li><div   ><ul   class="listLight"><li><div   ><ul   class="listLight"><li><div   ><a  href="https://www.javiercasas.com/articles/typescript-adts"  >ADTs</a></div></li></ul></div></li></ul></div></li><li><div   ><ul   class="listLight"><li><div   ><ul   class="listLight"><li><div   ><a  href="https://blog.logrocket.com/pattern-matching-and-type-safety-in-typescript-1da1231a2e34/"  >Types</a></div></li></ul></div></li></ul></div></li></ul></div></div>
<div   class="cardLight hoverShadowLight outlinedLight paddedbottomLight paddedtopLight shadowLight alignmentleftLight"><h3 id="GameIdea"  ><a  href="#GameIdea"  >#</a>
 Game Idea</h3>
<div   ><p   >Idea:</p>
<ul   class="listLight"><li><div   >Economy based, like Underlords. Win streaks, lose streaks and interest.</div></li><li><div   >RTS tech tree</div></li><li><div   >Starting positioning is key. Use a larger starting area that Underlords to see how that evolves gameplay.</div></li><li><div   >Terrain variety</div></li><li><div   >Faster + more rounds than Underlords</div></li><li><div   >Hyperfast. 30s tops per round.</div></li></ul>
<p   >Architecture:</p>
<ul   class="listLight"><li><div   >Erlang-based backend</div></li><li><div   ><ul   class="listLight"><li><div   >Elixir for the server: 'glue' + db</div></li></ul></div></li><li><div   ><ul   class="listLight"><li><div   >Rust as a NIF. The input is pulled from an ETS/Redis, ran through Rust, then put back. Treated as a functional lib that can be called.</div></li></ul></div></li><li><div   ><ul   class="listLight"><li><div   ><a  href="https://github.com/rusterlium/rustler"  >Rustler</a>
 will be used for writing NIFs. I'll likely write a script that automates part of this.</div></li></ul></div></li><li><div   >RabbitMQ for messaging</div></li><li><div   >Native clients that render some form of DSL to interact with the backend</div></li><li><div   ><ul   class="listLight"><li><div   >When releasing versions, have a locally seeded db. This then gets updated as time goes on through the server.</div></li></ul></div></li><li><div   ><ul   class="listLight"><li><div   >The locally seeded db is utilized when no internet is available or the player does not want to play online + update. </div></li></ul></div></li><li><div   ><ul   class="listLight"><li><div   >When they want to go online, it pulls data from the server. </div></li></ul></div></li><li><div   >Network + Serialization</div></li><li><div   ><ul   class="listLight"><li><div   >Ratelimiting</div></li></ul></div></li><li><div   ><ul   class="listLight"><li><div   >Elixir Channels for communication protocol</div></li></ul></div></li><li><div   ><ul   class="listLight"><li><div   >REST for non-websockety things (login, logout, etc.)</div></li></ul></div></li><li><div   ><ul   class="listLight"><li><div   >Preprocessor that looks at Rust structs + enum, then outputs DTO's in all client + server languages. Haskell is another option.</div></li></ul></div></li><li><div   ><ul   class="listLight"><li><div   >FlatBuffers for communication. 
<a  href="https://google.github.io/flatbuffers/"  >See article</a>
. The spec is small, it's fast, and it's supported in most languages. </div></li></ul></div></li><li><div   ><ul   class="listLight"><li><div   >Serialization is done in Rust, passed as a byte array to Elixir's channel, then sent out. Deserialized on the client, stored in the local db, done.</div></li></ul></div></li></ul></div></div></div></div></div>
            </div>
        </div>
    </body>
</html>
