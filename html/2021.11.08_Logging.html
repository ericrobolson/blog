
<!DOCTYPE html>
<html>
    <head>
        <title>Logging</title>
        <!-- metadata -->
        <meta charset="UTF-8">
<meta name="description" content="Building out a crate for logging + replaying events.">
<meta name="keywords" content="rust, open, source, mit, timer, timing, crate, library, gamedev">
<meta name="author" content="Eric Olson">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
        <!-- css -->
        <link rel="stylesheet" href="assets/styles.css">
    </head>
    <body>
        <!-- page class -->
        <div class=pageLight>
            <!-- content wrapper -->
            <div class=contentWrapperLight>
                <!-- content -->
                <div   ><div   ><div   class="navbottomLight"><a id="previous_page_link" href="2021.11.07_TimersAndGamedev.html"  >ðŸ¡„ Previous</a>
Forward ðŸ¡†</div>
<div   class="navtopLight"><a id="homeNav" href="index.html"  >Home</a>
<a id="catalogNav" href="catalog.html"  >Catalog</a>
<a id="projectsNav" href="projects.html"  >Projects</a>
<a id="aboutMeNav" href="about_me.html"  >About Me</a></div></div>
<div   ><h2 id="title"  ><a  href="#title"  >#</a>
2021.11.08 - Logging</h2>
<div   >



<div   class="cardLight hoverShadowLight outlinedLight paddedbottomLight paddedtopLight shadowLight alignmentleftLight"><h3 id="0552"  ><a  href="#0552"  >#</a>
 0552</h3>
<div   ><p   >Last week I did something to my left hand. I can type no problem, but gripping things was... uncomfortable to say the least. Usually when an injury happens I take a cycle off (e.g. push/pull/legs) and reevaluate after that. Until then I'll likely start hacking away earlier than normal. Rarely will I try to power through an injury now.</p>
<p   >Today I'll write up a logging library I wrote up. The reason I did this was to get deterministic (or close to) replays. It should greatly help when diagnosing issues as I can simply load in a replay file and rerun it.</p>
<p   >One thing I've started doing is only enabling file i/o on my libraries when a certain feature flag is enabled. The reason for this is I can then minimize divergent code paths in my actual applications. I'm attempting to keep the control flow relatively static to help make things easier to maintain.</p>
<p   >The main file of this library is a fantastic example of what I'm talking about. What I do in here is I disable features by default, only bringing in external dependencies when the <span   class="codeblockDark outlinedDark">log</span> feature is enabled. I provide a static interface to deal with this code for simplicity on the caller's side.</p>
<div   class="codeblockDark contentWrapperLight hoverShadowLight outlinedDark paddedbottomLight paddedtopLight shadowLight">
// lib.rs

#![cfg_attr(not(feature = "log"), no_std)]

#[cfg(feature = "log")]
#[macro_use]
extern crate lazy_static;

#[cfg(feature = "log")]
mod logger;

/// A class to log or replay items.
pub struct Logger;

impl Logger {
    /// Logs the given item
    #[allow(unused_variables)]
    pub fn log&lt;'a>(item: &amp;'a [u8]) {
        #[cfg(feature = "log")]
        {
            logger::log(item)
        }
    }

    /// Creates a new logger.
    /// `log_path` is the path to save the logs to.
    /// `replay_path` is the path to attempt to read replays from.
    #[allow(unused_variables)]
    pub fn load_replay&lt;'a>(replay_path: &amp;'a str) {
        #[cfg(feature = "log")]
        {
            logger::load_replay(replay_path);
        }
    }

    /// Attempts to replay an item. Returns `Some` if it was read with the bytes read, `None` if it was not.
    #[allow(unused_variables)]
    pub fn read_replay&lt;'a>(buffer: &amp;mut [u8]) -> Option&lt;usize> {
        #[cfg(feature = "log")]
        {
            return logger::read_replay(buffer);
        }

        None
    }

    /// Saves the logs to the provided file
    #[allow(unused_variables)]
    pub fn save_logs&lt;'a>(file: &amp;'a str) {
        #[cfg(feature = "log")]
        {
            logger::save_logs(file);
        }
    }
}
</div>
<p   >The next critical piece is the module <span   class="codeblockDark outlinedDark">logger</span> that is only enabled when the feature flag <span   class="codeblockDark outlinedDark">log</span> is turned on. If you were wondering how I allow multithreaded contexts, you can see that now.</p>
<p   >Typically what I'll do in these sort of 'opt in' libraries is use a <span   class="codeblockDark outlinedDark">lazy_static</span> macro which creates one instance of a class for an entire application. I then wrap it in a mutex to ensure no invalid access occurs.</p>
<div   class="codeblockDark contentWrapperLight hoverShadowLight outlinedDark paddedbottomLight paddedtopLight shadowLight">
mod logger;
use logger::Logger;

use std::{borrow::BorrowMut, sync::Mutex};

lazy_static! {
    /// Create a single logger instance that can be logged to.
    pub(crate) static ref LOGGER: Mutex&lt;Logger> = Mutex::new(Logger::new());
}

/// Loads a replay file
pub fn load_replay&lt;'a>(replay_path: &amp;'a str) {
    LOGGER.lock().unwrap().borrow_mut().load_replay(replay_path);
}

/// Logs the given item
pub fn log&lt;'a>(item: &amp;'a [u8]) {
    LOGGER.lock().unwrap().borrow_mut().log(item);
}

/// Attempts to read a replay item and returns the bytes read
pub fn read_replay&lt;'a>(buffer: &amp;mut [u8]) -> Option&lt;usize> {
    LOGGER.lock().unwrap().borrow_mut().read_replay(buffer)
}

/// Logs the given item
pub fn save_logs&lt;'a>(file_path: &amp;'a str) {
    LOGGER.lock().unwrap().borrow_mut().save_logs(file_path);
}
</div>
<p   >Next up are the <span   class="codeblockDark outlinedDark">Log</span> and <span   class="codeblockDark outlinedDark">LogFile</span> classes in my <span   class="codeblockDark outlinedDark">logger.rs</span> file. </p>
<div   class="codeblockDark contentWrapperLight hoverShadowLight outlinedDark paddedbottomLight paddedtopLight shadowLight">
use serde::{Deserialize, Serialize};
use std::fs::File;
use std::io::prelude::*;
use std::time::{Duration, Instant};

/// Representation of a log.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Log {
    /// The item to log. Stored in little endian.
    pub item: Vec&lt;u8>,
    /// The duration at which the log was ran since the program start.
    pub time: Duration,
}

/// A log file
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct LogFile {
    pub logs: Vec&lt;Log>,
}
</div>
<p   >The <span   class="codeblockDark outlinedDark">Log</span> takes in a vector of bytes to allow the caller to use whatever storage mechanism they would like. It also has a <span   class="codeblockDark outlinedDark">time</span> property to denote when an event occurred after the program started. The <span   class="codeblockDark outlinedDark">LogFile</span> is simply a collection of <span   class="codeblockDark outlinedDark">Log</span>s.</p>
<p   >The real guts of this library is the <span   class="codeblockDark outlinedDark">Logger</span> class, though it is not exposed to the client in any way. First I'll show the struct then go into the methods one by one.</p>
<div   class="codeblockDark contentWrapperLight hoverShadowLight outlinedDark paddedbottomLight paddedtopLight shadowLight">
pub struct Logger {
    log_current_duration: Duration,
    log_last_tick: Instant,
    logs: LogFile,
    replay_current_duration: Duration,
    replay_idx: usize,
    replay_last_tick: Instant,
    replay_logs: LogFile,
}

impl Logger {
    ...
    /// Creates a new logger
    pub fn new() -> Self {
        Self {
            log_current_duration: Duration::from_micros(0),
            log_last_tick: Instant::now(),
            logs: LogFile::new(),
            replay_current_duration: Duration::from_micros(0),
            replay_idx: 0,
            replay_last_tick: Instant::now(),
            replay_logs: LogFile::new(),
        }
    }
    ...
}
</div>
<p   >Next up is the <span   class="codeblockDark outlinedDark">log()</span> method which takes in a slice of bytes and adds a log for it. I want to explicitly call out the mapping of bytes to the little endian format, as that will help ensure cross platform determinism. </p>
<div   class="codeblockDark contentWrapperLight hoverShadowLight outlinedDark paddedbottomLight paddedtopLight shadowLight">
/// Logs the given item
pub fn log&lt;'a>(&amp;mut self, item: &amp;'a [u8]) {
    let now = Instant::now();
    self.log_current_duration += now - self.log_last_tick;
    self.log_last_tick = now;

    let log = Log {
        item: item.iter().map(|l| l.to_le()).collect(),
        time: self.log_current_duration,
    };

    self.logs.logs.push(log);
}
</div>
<p   >Next is the saving of logs. I did not wrap it in a <span   class="codeblockDark outlinedDark">Result</span> as the goal for this library is debug builds and not production builds. It is on my roadmap but I don't know when I'll get to it.</p>
<p   >Serde is used for serialization and deserialization as I like how easy it is to utilize. JSON is the format of choice.</p>
<div   class="codeblockDark contentWrapperLight hoverShadowLight outlinedDark paddedbottomLight paddedtopLight shadowLight">
/// Saves the log file
pub fn save_logs&lt;'a>(&amp;mut self, log_path: &amp;'a str) {
    let mut file = match File::create(log_path) {
        Ok(f) => f,
        Err(e) => panic!("Error saving Logger logs: {:?}", e),
    };

    let serialized = serde_json::to_string(&amp;self.logs).unwrap();
    file.write_all(serialized.as_bytes()).unwrap();
}
</div>
<p   >Next up is the loading of replays. This method simply resets the durations, the current indexes and the last tick. A file is the loaded into memory.</p>
<div   class="codeblockDark contentWrapperLight hoverShadowLight outlinedDark paddedbottomLight paddedtopLight shadowLight">
/// Loads a replay
pub fn load_replay&lt;'a>(&amp;mut self, replay_path: &amp;'a str) {
    self.replay_current_duration = Duration::from_micros(0);
    self.replay_idx = 0;
    self.replay_last_tick = Instant::now();

    let mut file = File::open(replay_path).unwrap();
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents).unwrap();

    self.replay_logs = serde_json::from_str(&amp;contents).unwrap();
}
</div>
<p   >The most complex bit is the <span   class="codeblockDark outlinedDark">read_replay()</span> method. I toyed around with several ways to go about implementing it, but the most surefire way ensure I didn't constantly allocate memory was by passing in a buffer and writing to that.</p>
<p   >It will crash if the buffer is too small, which is an unfortunate decision but one I will not change right now. I would like to move onto other functionality.</p>
<p   >In this method I will take the serialized log, convert the bytes to the native endianness from little endian and return an item if it was at the proper duration.</p>
<div   class="codeblockDark contentWrapperLight hoverShadowLight outlinedDark paddedbottomLight paddedtopLight shadowLight">
/// Reads a replay item with the bytes read
pub fn read_replay&lt;'a>(&amp;mut self, buffer: &amp;mut [u8]) -> Option&lt;usize> {
    // increment time since last read
    let now = Instant::now();
    self.replay_current_duration += now - self.replay_last_tick;
    self.replay_last_tick = now;

    // Check if there are more replays to use
    if self.replay_logs.logs.len() > self.replay_idx {
        let log = &amp;self.replay_logs.logs[self.replay_idx];

        // If the current duration is greater or equal to the log time, return it and prep the next replay
        if self.replay_current_duration >= log.time {
            self.replay_idx += 1;

            if buffer.len() &lt; log.item.len() {
                panic!(
                    "BUFFER OVERFLOW for item {:?}! Buffer was {buffer_len} bytes, item was {item_len} bytes.",
                    log = log,
                    buffer_len = buffer.len(),
                    item_len = log.item.len()
                )
            }

            let mut count = 0;
            for byte in log.item.iter() {
                buffer[count] = u8::from_le(*byte);

                count += 1;
            }

            return Some(count);
        }
    }

    None
}
</div>
<p   >I will likely post more crates like this as time goes on as it's the least I can do for the internet.</p></div></div></div></div></div>
            </div>
        </div>
    </body>
</html>
