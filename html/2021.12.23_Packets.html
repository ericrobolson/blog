
<!DOCTYPE html>
<html>
    <head>
        <title>Packet serialization</title>
        <!-- metadata -->
        <meta charset="UTF-8">
<meta name="description" content="Implementing a form of packet serialization.">
<meta name="keywords" content="lisp, rust, web, app, cargo, 3d, 2d, cross, platform, monogame, bot, godot, curl, wasm, algebraic, data, types, synthesizer, notes, bottom, up, test, driven, code, generation, development, tdd, packet, serialization">
<meta name="author" content="Eric Olson">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
        <!-- css -->
        <link rel="stylesheet" href="assets/styles.css">
    </head>
    <body>
        <!-- page class -->
        <div class=pageLight>
            <!-- content wrapper -->
            <div class=contentWrapperLight>
                <!-- content -->
                <div   ><div   ><div   class="navbottomLight"><a id="previous_page_link" href="2021.12.22_MusicTimelines.html"  >ðŸ¡„ Previous</a>
Forward ðŸ¡†</div>
<div   class="navtopLight"><a id="homeNav" href="index.html"  >Home</a>
<a id="catalogNav" href="catalog.html"  >Catalog</a>
<a id="projectsNav" href="projects.html"  >Projects</a>
<a id="aboutMeNav" href="about_me.html"  >About Me</a></div></div>
<div   ><h2 id="title"  ><a  href="#title"  >#</a>
2021.12.23 - Packet serialization</h2>
<div   >



<div   class="cardLight hoverShadowLight outlinedLight paddedbottomLight paddedtopLight shadowLight alignmentleftLight"><h3 id="0755"  ><a  href="#0755"  >#</a>
 0755</h3>
<div   ><p   >I'm taking a bit of a break from the music project as I wanted to hack some lower level shit. I've been working on a form of netcode modeled after Tribes 2.</p>
<p   >The basic idea is everything is unreliable, but the user of the library will be notified when a packet is either delivered or not delivered. I still need to work out some details, but going with the bottom up approach I've started with packet creation, serialization and deserialization.</p>
<p   >Leveraging unit tests helped a bunch, as I'm hoping when this gets tested out I don't need to worry about edge cases.</p>
<p   >The following is a large amount of code, but hopefully someone will find it useful.</p>
<div   class="codeblockDark contentWrapperLight hoverShadowLight outlinedDark paddedbottomLight paddedtopLight shadowLight">
use crate::{
    packet_id::{self, PacketId},
    PacketErr,
};

type AckBitfield = u32;
type Crc32Hash = u32;
type PacketLen = u16;

const ACK_ID_SIZE: usize = core::mem::size_of::&lt;PacketId>();
const PACKET_ID_SIZE: usize = core::mem::size_of::&lt;PacketId>();
const ACK_BITFIELD_SIZE: usize = core::mem::size_of::&lt;AckBitfield>();
const CRC32_HASH_SIZE: usize = core::mem::size_of::&lt;Crc32Hash>();
const PACKET_LEN_SIZE: usize = core::mem::size_of::&lt;PacketLen>();

// the indices of the headers
const PACKET_LEN_START_IDX: usize = 0;
const PACKET_LEN_END_IDX: usize = PACKET_LEN_SIZE;

const CRC32_START_IDX: usize = PACKET_LEN_END_IDX;
const CRC32_END_IDX: usize = CRC32_START_IDX + CRC32_HASH_SIZE;

const PACKET_ID_START_IDX: usize = CRC32_END_IDX;
const PACKET_ID_END_IDX: usize = PACKET_ID_START_IDX + PACKET_ID_SIZE;

const ACK_ID_START_IDX: usize = PACKET_ID_END_IDX;
const ACK_ID_END_IDX: usize = ACK_ID_START_IDX + ACK_ID_SIZE;

const ACK_BITFIELD_START_IDX: usize = ACK_ID_END_IDX;
const ACK_BITFIELD_END_IDX: usize = ACK_BITFIELD_START_IDX + ACK_BITFIELD_SIZE;

/// The size of the header.
const HEADER_SIZE: usize =
    ACK_ID_SIZE + ACK_BITFIELD_SIZE + CRC32_HASH_SIZE + PACKET_ID_SIZE + PACKET_LEN_SIZE;

/// The max packet size to deal with fragmentation.
const MAX_PACKET_SIZE: usize = 420;
/// The maximum size of the contents for the packet.
const MAX_PACKET_CONTENTS: usize = MAX_PACKET_SIZE - HEADER_SIZE;

/// A packet that can be sent over the wire.
/// The packet itself is serialized and deserialized in the little endian format
/// so as to preserve cross platform determinism.
#[derive(Clone, Debug, PartialEq)]
pub struct Packet {
    /// The last packet to ack.
    ack: PacketId,
    /// Previous acks. If the Nth bit is set, that means ack - n is acked.
    acks: AckBitfield,
    /// The total contents of the packet. Includes header + user content.
    bytes: [u8; MAX_PACKET_SIZE],
    /// CRC32 hash
    crc32hash: Crc32Hash,
    /// The current length of the packet's bytes.
    len: usize,
    /// The maximum allowed length of the packet.
    packet_capacity: usize,
    /// The packet id.
    packet_id: PacketId,
}

impl Packet {
    /// The max number of packets that can be acked.
    /// Since a u32 is used for storing the acks, we'll limit it to that many values.
    pub(crate) const MAX_ACKS: packet_id::Inner = 32;

    /// Acks the given packet if possible.
    pub(crate) fn ack(&amp;mut self, packet: PacketId) {
        // Only set a bit if it's not the original ack
        if packet != self.ack {
            let diff = self.ack - packet;

            // If difference is greater than the max ack window or is the same ack, ignore.
            if diff.inner() &lt;= Self::MAX_ACKS {
                let ack = 1 &lt;&lt; (diff.inner() - 1);
                self.acks |= ack;
            }
        }
    }

    /// Returns the packets bytes.
    /// NOTE: this does not perform serialization, that is done
    /// as a packet is written.
    /// write_header() should also be called before returning the
    /// packet, as that way the CRC32 sumcheck is added in.
    pub(crate) fn bytes(&amp;self) -> &amp;[u8] {
        &amp;self.bytes[0..self.len]
    }

    /// Returns the contents of the packet.
    pub fn contents(&amp;self) -> &amp;[u8] {
        &amp;self.bytes[HEADER_SIZE..self.len]
    }

    /// Attempts to deserialize the packet
    pub fn from_bytes(bytes: &amp;[u8]) -> Result&lt;Self, PacketErr> {
        // Ensure we don't overflow
        if bytes.len() > MAX_PACKET_SIZE {
            return Err(PacketErr::WouldOverflow);
        }

        // Read in the bytes
        let mut packet = Packet::new(0.into(), 0.into(), MAX_PACKET_SIZE);
        for (idx, byte) in bytes.iter().enumerate() {
            packet.bytes[idx] = *byte;
        }

        // Now deserialize all things
        let packet_len = PacketLen::from_le_bytes([
            packet.bytes[PACKET_LEN_START_IDX],
            packet.bytes[PACKET_LEN_END_IDX - 1],
        ]);

        let packet_id: PacketId = packet_id::Inner::from_le_bytes([
            packet.bytes[PACKET_ID_START_IDX],
            packet.bytes[PACKET_ID_END_IDX - 1],
        ])
        .into();

        let ack: PacketId = packet_id::Inner::from_le_bytes([
            packet.bytes[ACK_ID_START_IDX],
            packet.bytes[ACK_ID_END_IDX - 1],
        ])
        .into();

        let acks: AckBitfield = AckBitfield::from_le_bytes([
            packet.bytes[ACK_BITFIELD_START_IDX],
            packet.bytes[ACK_BITFIELD_START_IDX + 1],
            packet.bytes[ACK_BITFIELD_START_IDX + 2],
            packet.bytes[ACK_BITFIELD_END_IDX - 1],
        ])
        .into();

        let crc32hash: Crc32Hash = Crc32Hash::from_le_bytes([
            packet.bytes[CRC32_START_IDX],
            packet.bytes[CRC32_START_IDX + 1],
            packet.bytes[CRC32_START_IDX + 2],
            packet.bytes[CRC32_END_IDX - 1],
        ]);

        // Build up packet
        packet.len = packet_len as usize;
        packet.ack = ack;
        packet.packet_id = packet_id;
        packet.acks = acks;
        packet.crc32hash = crc32hash;

        // Now verify the crc32 matches
        packet.zero_crc32_bytes();
        if crc32fast::hash(&amp;packet.bytes()) != packet.crc32hash {
            Err(PacketErr::ChecksumMismatch)
        } else {
            Ok(packet)
        }
    }

    /// Returns the id of the packet
    pub fn id(&amp;self) -> PacketId {
        self.packet_id
    }

    /// Returns the length of the packet in bytes.
    pub(crate) fn len(&amp;self) -> usize {
        self.len
    }

    /// Creates a new packet
    pub(crate) fn new(packet_id: PacketId, ack: PacketId, packet_capacity: usize) -> Self {
        Self {
            ack,
            acks: 0,
            bytes: [0; MAX_PACKET_SIZE],
            crc32hash: 0,
            packet_id,
            len: HEADER_SIZE,
            packet_capacity,
        }
    }

    /// Writes the given byte to the packet.
    /// It will be converted to little endian before serialization.
    /// Returns the number of bytes remaining for the packet.
    pub fn write(&amp;mut self, byte: u8) -> Result&lt;usize, PacketErr> {
        if self.len() >= self.packet_capacity {
            Err(PacketErr::WouldOverflow)
        } else {
            self.bytes[self.len] = byte.to_le();
            self.len += 1;

            Ok(self.packet_capacity - self.len)
        }
    }

    /// Writes the header to the packet.
    /// This should be called before any serialization happens.
    pub(crate) fn write_header(&amp;mut self) {
        // Write packet len
        {
            let packet_len = (self.len as PacketLen).to_le_bytes();
            let mut idx = PACKET_LEN_START_IDX;
            for byte in packet_len {
                self.bytes[idx] = byte;
                idx += 1;
            }
        }

        // Write packet id
        {
            let packet_id = self.packet_id.inner().to_le_bytes();
            let mut idx = PACKET_ID_START_IDX;
            for byte in packet_id {
                self.bytes[idx] = byte;
                idx += 1;
            }
        }

        // Write ack id
        {
            let ack_id = self.ack.inner().to_le_bytes();
            let mut idx = ACK_ID_START_IDX;
            for byte in ack_id {
                self.bytes[idx] = byte;
                idx += 1;
            }
        }

        // Write ack bitfields
        {
            let ack_bitfield = self.acks.to_le_bytes();
            let mut idx = ACK_BITFIELD_START_IDX;
            for byte in ack_bitfield {
                self.bytes[idx] = byte;
                idx += 1;
            }
        }

        // Write all the header info

        // First zero out all crc32 bytes
        self.zero_crc32_bytes();

        // Hash the contents
        let hash = crc32fast::hash(&amp;self.bytes());

        // Write CRC32 hash
        {
            let hash = hash.to_le_bytes();
            let mut idx = CRC32_START_IDX;
            for byte in hash {
                self.bytes[idx] = byte;
                idx += 1;
            }
        }
    }

    /// Zeroes out all CRC32 bytes.
    fn zero_crc32_bytes(&amp;mut self) {
        for idx in CRC32_START_IDX..CRC32_END_IDX {
            self.bytes[idx] = 0;
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    mod ack {
        use super::*;

        #[test]
        fn ack_packet_n1_sets_first_bit() {
            let ack = 1;

            let mut packet = Packet::new(3.into(), ack.into(), 40);

            let mut expected = packet.clone();
            expected.acks = 1;

            packet.ack((ack - 1).into());
            assert_eq!(expected, packet);
        }

        #[test]
        fn ack_packet_2n_sets_second_bit() {
            let n = 2;
            let ack = 4444;

            let mut packet = Packet::new(3.into(), ack.into(), 40);

            let mut expected = packet.clone();
            expected.acks = 0b_0010;

            packet.ack((ack - n).into());
            assert_eq!(expected, packet);
        }

        #[test]
        fn ack_packet_4n_sets_fourth_bit() {
            let n = 4;
            let ack = packet_id::Inner::MAX;

            let mut packet = Packet::new(3.into(), ack.into(), 40);

            let mut expected = packet.clone();
            expected.acks = 0b_1000;

            packet.ack((ack - n).into());
            assert_eq!(expected, packet);
        }

        #[test]
        fn ack_packet_8n_sets_eighth_bit() {
            let n = 8;
            let ack = packet_id::Inner::MAX;

            let mut packet = Packet::new(3.into(), ack.into(), 40);

            let mut expected = packet.clone();
            expected.acks = 0b_1000_0000;

            packet.ack((ack - n).into());
            assert_eq!(expected, packet);
        }

        #[test]
        fn ack_packet_16n_sets_sixteenth_bit() {
            let n = 16;
            let ack = 1;

            let mut packet = Packet::new(3.into(), ack.into(), 40);

            let mut expected = packet.clone();
            expected.acks = 0b_1000_0000_0000_0000;

            packet.ack((ack - n).into());
            assert_eq!(expected, packet);
        }

        #[test]
        fn ack_packet_32n_sets_32nd_bit() {
            let n = 32;
            let ack = 1;

            let mut packet = Packet::new(3.into(), ack.into(), 40);

            let mut expected = packet.clone();
            expected.acks = 0b_1000_0000_0000_0000_0000_0000_0000_0000;

            packet.ack((ack - n).into());
            assert_eq!(expected, packet);
        }

        #[test]
        fn ack_packet_33n_does_nothing() {
            let n = 33;
            let ack = 1;

            let mut packet = Packet::new(3.into(), ack.into(), 40);

            let mut expected = packet.clone();
            expected.acks = 0;

            packet.ack((ack - n).into());
            assert_eq!(expected, packet);
        }

        #[test]
        fn ack_packet_does_not_modify_existing() {
            let n = 2;
            let ack = 1;

            let mut packet = Packet::new(3.into(), ack.into(), 40);

            let mut expected = packet.clone();
            expected.acks = 0b0011;

            packet.acks = expected.acks;

            packet.ack((ack - n).into());
            assert_eq!(expected, packet);
        }

        #[test]
        fn ack_greater_than_original_does_nothing() {
            let ack = 0;

            let mut packet = Packet::new(3.into(), ack.into(), 40);

            let expected = packet.clone();

            packet.ack(1.into());
            assert_eq!(expected, packet);
        }

        #[test]
        fn ack_is_original_ack_does_nothing() {
            let ack = 0;

            let mut packet = Packet::new(3.into(), ack.into(), 40);

            let original = packet.clone();

            packet.ack(ack.into());
            assert_eq!(original, packet);
        }

        #[test]
        fn ack_outside_window_does_nothing() {
            let ack = Packet::MAX_ACKS + 1;

            let mut packet = Packet::new(3.into(), ack.into(), 40);

            let original = packet.clone();

            packet.ack(0.into());
            assert_eq!(original, packet);
        }
    }

    mod bytes {
        use super::*;

        #[test]
        fn returns_expected() {
            let mut packet = Packet::new(0.into(), 22.into(), 33);
            let size = 10;
            for _ in 0..size {
                packet.write(3).unwrap();
            }

            assert_eq!(&amp;packet.bytes[0..HEADER_SIZE + size], packet.bytes())
        }
    }

    mod contents {
        use super::*;

        #[test]
        fn returns_expected() {
            let mut packet = Packet::new(0.into(), 22.into(), 33);
            let size = 10;
            let mut bytes = vec![];
            for i in 0..size {
                packet.write(i as u8).unwrap();
                bytes.push(i as u8);
            }

            assert_eq!(&amp;bytes, packet.contents())
        }
    }

    mod from_bytes {
        use super::*;
        fn packet(content_len: usize) -> Packet {
            let mut packet = Packet::new(34.into(), 37.into(), MAX_PACKET_SIZE);
            for _ in 0..content_len {
                packet.write(34).unwrap();
            }
            packet
        }

        #[test]
        fn would_overflow_returns_error() {
            let bytes = [0; MAX_PACKET_SIZE + 1];
            assert_eq!(Err(PacketErr::WouldOverflow), Packet::from_bytes(&amp;bytes));
        }

        #[test]
        fn at_capacity_returns_expected() {
            let mut packet = packet(MAX_PACKET_CONTENTS);
            packet.write_header();

            let mut result = Packet::from_bytes(packet.bytes()).unwrap();

            // We don't actually care about the checksums,
            // as if it deserializes they pass.
            // Reset them for this test.
            packet.zero_crc32_bytes();
            result.crc32hash = 0;

            assert_eq!(packet.clone(), result);
        }

        #[test]
        fn less_than_capacity_returns_expected() {
            let mut packet = packet(33);
            packet.write_header();

            let mut result = Packet::from_bytes(packet.bytes()).unwrap();

            // We don't actually care about the checksums,
            // as if it deserializes they pass.
            // Reset them for this test.
            packet.zero_crc32_bytes();
            result.crc32hash = 0;

            assert_eq!(packet.clone(), result);
        }

        #[test]
        fn invalid_checksum_returns_error() {
            let mut packet = packet(33);
            packet.write_header();

            packet.bytes[HEADER_SIZE + 3] = 255;

            let result = Packet::from_bytes(packet.bytes());

            assert_eq!(Err(PacketErr::ChecksumMismatch), result);
        }
    }

    mod len {
        use super::*;

        #[test]
        fn new_packet_has_header_as_len() {
            let packet = Packet::new(0.into(), 0.into(), 33);
            assert_eq!(HEADER_SIZE, packet.len())
        }

        #[test]
        fn writing_modifies_len() {
            let mut packet = Packet::new(0.into(), 0.into(), 33);
            let num_writes = 13;
            for _ in 0..num_writes {
                packet.write(0).unwrap();
            }

            assert_eq!(HEADER_SIZE + num_writes, packet.len())
        }
    }

    mod new {
        use super::*;

        #[test]
        fn returns_expected() {
            let packet_capacity = 100;
            let packet_id: PacketId = 34.into();
            let ack_id: PacketId = 3333.into();

            let expected = Packet {
                ack: ack_id,
                acks: 0,
                bytes: [0; MAX_PACKET_SIZE],
                crc32hash: 0,
                len: HEADER_SIZE,
                packet_capacity,
                packet_id,
            };

            let actual = Packet::new(packet_id, ack_id, packet_capacity);
            assert_eq!(expected, actual);
        }
    }

    mod write {
        use super::*;

        #[test]
        fn would_not_overflow_returns_remaining_len() {
            let capacity = 300;
            let mut packet = Packet::new(0.into(), 0.into(), capacity);
            let idx = packet.len();
            let result = packet.write(1);

            assert_eq!(Ok(packet.packet_capacity - HEADER_SIZE - 1), result);
            assert_eq!(HEADER_SIZE + 1, packet.len);
            assert_eq!(1, packet.bytes[idx]);
        }

        #[test]
        fn boundary_does_not_overflow() {
            let capacity = 300;
            let mut packet = Packet::new(0.into(), 0.into(), capacity);
            packet.len = capacity - 1;
            let idx = packet.len();
            let result = packet.write(1);

            assert_eq!(Ok(0), result);
            assert_eq!(capacity, packet.len);
            assert_eq!(1, packet.bytes[idx]);
        }

        #[test]
        fn overflow_does_nothing() {
            let capacity = 300;
            let mut packet = Packet::new(0.into(), 0.into(), capacity);
            packet.len = capacity;
            let result = packet.write(1);

            assert_eq!(Err(PacketErr::WouldOverflow), result);
        }

        #[test]
        fn packet_writes_little_endian() {
            let capacity = 300;
            let mut packet = Packet::new(0.into(), 0.into(), capacity);
            let idx = packet.len();

            let byte: u8 = 233_u8.to_be();

            let result = packet.write(byte);

            assert_eq!(Ok(packet.packet_capacity - HEADER_SIZE - 1), result);
            assert_eq!(HEADER_SIZE + 1, packet.len);
            assert_eq!(233_u8.to_le(), packet.bytes[idx]);
        }
    }

    mod write_header {
        use super::*;

        #[test]
        fn packet_len_is_written() {
            let mut packet = Packet::new(0.into(), 1.into(), 111);
            let writes = 33;
            for i in 0..writes {
                packet.write(i).unwrap();
            }

            packet.write_header();

            let packet_len: PacketLen = PacketLen::from_le_bytes([
                packet.bytes[PACKET_LEN_START_IDX],
                packet.bytes[PACKET_LEN_END_IDX - 1],
            ]);

            assert_eq!(HEADER_SIZE as PacketLen + writes as PacketLen, packet_len);
        }

        #[test]
        fn packet_id_is_written() {
            let id: PacketId = 3443.into();
            let mut packet = Packet::new(id, 1.into(), 111);

            packet.write_header();

            let packet_id = packet_id::Inner::from_le_bytes([
                packet.bytes[PACKET_ID_START_IDX],
                packet.bytes[PACKET_ID_END_IDX - 1],
            ]);

            assert_eq!(id.inner().to_le(), packet_id);
            assert_eq!(id, packet_id.into());
        }

        #[test]
        fn ack_id_is_written() {
            let ack: PacketId = 34343.into();
            let mut packet = Packet::new(0.into(), ack, 111);

            packet.write_header();

            let ack_id = packet_id::Inner::from_le_bytes([
                packet.bytes[ACK_ID_START_IDX],
                packet.bytes[ACK_ID_END_IDX - 1],
            ]);

            assert_eq!(ack.inner().to_le(), ack_id);
            assert_eq!(ack, ack_id.into());
        }

        #[test]
        fn bitfields_are_written() {
            let ack: PacketId = 34343.into();
            let mut packet = Packet::new(0.into(), ack, 111);

            packet.ack(ack.decrement());
            packet.ack(ack.decrement().decrement());
            packet.ack(ack.decrement().decrement().decrement().decrement());

            packet.write_header();

            let bitfield = AckBitfield::from_le_bytes([
                packet.bytes[ACK_BITFIELD_START_IDX],
                packet.bytes[ACK_BITFIELD_START_IDX + 1],
                packet.bytes[ACK_BITFIELD_START_IDX + 2],
                packet.bytes[ACK_BITFIELD_END_IDX - 1],
            ]);

            assert_eq!(packet.acks.to_le(), bitfield);
        }

        #[test]
        fn hash_is_written() {
            let ack: PacketId = 34343.into();
            let mut packet = Packet::new(0.into(), ack, 111);

            packet.ack(ack.decrement());
            packet.ack(ack.decrement().decrement());
            packet.ack(ack.decrement().decrement().decrement().decrement());

            let expected = {
                let mut clone = packet.clone();
                clone.write_header();
                clone.zero_crc32_bytes();
                crc32fast::hash(clone.bytes())
            };

            packet.write_header();

            let crc = Crc32Hash::from_le_bytes([
                packet.bytes[CRC32_START_IDX],
                packet.bytes[CRC32_START_IDX + 1],
                packet.bytes[CRC32_START_IDX + 2],
                packet.bytes[CRC32_END_IDX - 1],
            ]);

            assert_eq!(expected, crc);
        }
    }

    mod zero_crc32_bytes {
        use super::*;

        #[test]
        fn bytes_are_zeroed() {
            let mut packet = Packet::new(0.into(), 1.into(), 444);

            for i in CRC32_START_IDX..CRC32_END_IDX {
                packet.bytes[i] = i as u8;
            }

            packet.zero_crc32_bytes();

            for i in CRC32_START_IDX..CRC32_END_IDX {
                assert_eq!(0, packet.bytes[i])
            }
        }
    }
}
</div></div></div></div></div></div>
            </div>
        </div>
    </body>
</html>
