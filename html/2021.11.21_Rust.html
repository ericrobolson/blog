
<!DOCTYPE html>
<html>
    <head>
        <title>On how I use Rust and the next project</title>
        <!-- metadata -->
        <meta charset="UTF-8">
<meta name="description" content="Picking the next project, similarities between Rust and Elixir.">
<meta name="keywords" content="rust, elixir, vm, slay, the, spire">
<meta name="author" content="Eric Olson">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
        <!-- css -->
        <link rel="stylesheet" href="assets/styles.css">
    </head>
    <body>
        <!-- page class -->
        <div class=pageLight>
            <!-- content wrapper -->
            <div class=contentWrapperLight>
                <!-- content -->
                <div   ><div   ><div   class="navbottomLight"><a id="previous_page_link" href="2021.11.20_BlenderScriptsContinued6.html"  >ðŸ¡„ Previous</a>
<a id="next_page_link" href="2021.11.22_Menus.html"  >Forward ðŸ¡†</a></div>
<div   class="navtopLight"><a id="homeNav" href="index.html"  >Home</a>
<a id="catalogNav" href="catalog.html"  >Catalog</a>
<a id="projectsNav" href="projects.html"  >Projects</a>
<a id="aboutMeNav" href="about_me.html"  >About Me</a></div></div>
<div   ><h2 id="title"  ><a  href="#title"  >#</a>
2021.11.21 - On how I use Rust and the next project</h2>
<div   >



<div   class="cardLight hoverShadowLight outlinedLight paddedbottomLight paddedtopLight shadowLight alignmentleftLight"><h3 id="0011"  ><a  href="#0011"  >#</a>
 0011</h3>
<div   ><p   >I treat Rust as a dirty Haskell, if that makes sense. I've never used Haskell in a large scale, but I loved the pattern matching. Working with Elixir right now is similar. </p>
<p   >It can effectively use symbols as static types, where you add in a matching statement, catch cases you haven't written yet, and then go along. I need to figure out a way preserve uncaught areas, then restart the process from there.</p>
<p   >An idea:</p>
<ul   class="listLight"><li><div   >Write a macro:</div></li><li><div   ><ul   class="listLight"><li><div   >This effectively is a match statement in Rust</div></li></ul></div></li><li><div   ><ul   class="listLight"><li><div   >For unhandled cases, what it does is saves the calling method, the initial args, basically everything used to make the function call.</div></li></ul></div></li><li><div   ><ul   class="listLight"><li><div   >It saves it somewhere, to be replayed in the future.</div></li></ul></div></li><li><div   ><ul   class="listLight"><li><div   >Then you go through with the saved cases, write a unit test, redeploy</div></li></ul></div></li><li><div   ><ul   class="listLight"><li><div   >When redeployed, it recalls the functions to resume execution at that part</div></li></ul></div></li><li><div   ><ul   class="listLight"><li><div   >Stongly typed, so even though implementation can be deferred (basically the 
<span   class="codeblockDark outlinedDark">_</span>
 in a rust match) you MUST handle one of your specified cases</div></li></ul></div></li><li><div   ><ul   class="listLight"><li><div   >ADT based</div></li></ul></div></li><li><div   ><ul   class="listLight"><li><div   >This could also be a VM?</div></li></ul></div></li></ul>
<p   >I need to see how this can be used in Elixir, or how it can already be done. Then use in work. </p></div></div>
<div   class="cardLight hoverShadowLight outlinedLight paddedbottomLight paddedtopLight shadowLight alignmentleftLight"><h3 id="0633"  ><a  href="#0633"  >#</a>
 0633</h3>
<div   ><p   >I'll start building out some form of menu based system today. While I'd love to make some crazy massive immersive FPS looter shooter, that is simply not feasible to do with just myself.</p>
<p   >I'll go with a turn based system. Slay the Spire will be a heavy influence, though it could end up drastically different. </p>
<p   >One thing I'm unsure of is whether this should be a client/server game. Perhaps I'll do that?</p></div></div></div></div></div>
            </div>
        </div>
    </body>
</html>
