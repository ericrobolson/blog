
<!DOCTYPE html>
<html>
    <head>
        <title>Rollback Netcode</title>
        <!-- metadata -->
        <meta charset="UTF-8">
<meta name="description" content="Implementing a generic rollback netcode inspired by GGPO.">
<meta name="keywords" content="rust, gamedev, no_std, ggpo, rollback, netcode, fighting, game">
<meta name="author" content="Eric Olson">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
        <!-- css -->
        <link rel="stylesheet" href="assets/styles.css">
    </head>
    <body>
        <!-- page class -->
        <div class=pageLight>
            <!-- content wrapper -->
            <div class=contentWrapperLight>
                <!-- content -->
                <div   ><div   ><div   class="navbottomLight"><a id="previous_page_link" href="2021.09.28_CollisionPt2.html"  >ðŸ¡„ Previous</a>
<a id="next_page_link" href="2021.09.30_Rollback2.html"  >Forward ðŸ¡†</a></div>
<div   class="navtopLight"><a id="homeNav" href="index.html"  >Home</a>
<a id="catalogNav" href="catalog.html"  >Catalog</a>
<a id="projectsNav" href="projects.html"  >Projects</a>
<a id="aboutMeNav" href="about_me.html"  >About Me</a></div></div>
<div   ><h2 id="title"  ><a  href="#title"  >#</a>
2021.09.29 - Rollback Netcode</h2>
<div   >



<div   class="cardLight hoverShadowLight outlinedLight paddedbottomLight paddedtopLight shadowLight alignmentleftLight"><h3 id="0743"  ><a  href="#0743"  >#</a>
 0743</h3>
<div   ><p   >I've been working on adding a generic rollback netcode module. This does not take into account transport layers or anything of that sort, though I can see value in doing so. The purpose is to build out a purely algorithmic implementation where I can plug and play various games.</p>
<p   >Not sure this is the best approach, but it will hopefully let me reuse functionality across games (or even other apps).</p>
<p   >I don't think I'll go into the code quite yet, as this will drastically change over time. The basic algorithm is as follows:</p>
<ol  type="1" class="listLight"><li><div   > Set up initial game state</div></li><li><div   > Set up players (remote and local)</div></li><li><div   > Register local input at the current frame + N. This is done to deal with remote player latency.</div></li><li><div   > Tick the game state always. If a remote player input is received for a past frame, go back to the last 'confirmed' state and replay all inputs until the current frame. Save the most recent frame with all player inputs as the 'confirmed' state.</div></li></ol>
<p   >Like the previous posts, I'm taking a <span   class="codeblockDark outlinedDark">no_std</span> approach to ensure maximum platform compatibility. I'm also using a finite state automata (FSM) for logic. That deserves another post, but the gist is that I can ensure logic occurs under certain scenarios.</p>
<p   >Another thing I've started doing is a <span   class="codeblockDark outlinedDark">check_targets</span> script which will build my crates against all possible architectures I may want. This way I can ensure I'm always writing code that will work.</p></div></div></div></div></div>
            </div>
        </div>
    </body>
</html>
